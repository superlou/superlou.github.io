<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer-when-downgrade">

    <title>Embedded Cross-Compiled Test Driven Development with CGull</title>
    <meta name="description" content="">

    <link rel="stylesheet" href="https:&#x2F;&#x2F;www.louissimons.com&#x2F;main.css">

    

    
<link rel="stylesheet" href="https:&#x2F;&#x2F;www.louissimons.com&#x2F;style.css">


</head>
<body>
    <a class="skip-main" href="#main">Skip to content</a>
    <div class="container">
        <header> 
            <h1 class="site-header">
                <a href="https:&#x2F;&#x2F;www.louissimons.com&#x2F;">lack of focus</a>
            </h1>
            <nav>
                


<a  href="https:&#x2F;&#x2F;www.louissimons.com&#x2F;&#x2F;about&#x2F;">About</a>


<div class="search-container">
  <input id="search" type="search" placeholder="ðŸ”Ž">
  <div class="search-results" style="display: none;">
    <div class="search-results__items"></div>
  </div>
</div>

            </nav>
        </header>
        <main id="main" tabindex="-1">
            

<article class="post">
    <header>
        <h1>Embedded Cross-Compiled Test Driven Development with CGull</h1>
    </header>
    <div class="content">
        <p>Testing bare-metal embedded C isn't straightforward. Someone will shout &quot;stop using printf,&quot; and you'll yell back, &quot;what's a printf?&quot; They'll follow up with something about emulators. They're not wrong, but how do you efficiently regression test on the emulation target? Sure, you'll eventually have Requirements Based Tests (RBT) and &quot;black box test procedures,&quot; but they are hardware-in-the-loop and tedious to run. A full RBT suite can take weeks to execute with a combination of manual and scripted tests. The pathway to happiness isn't simply a fast &quot;edit-compile-run&quot; development loop, but a &quot;edit-compile-run-It Works and Didn't Break Something Else&quot; cycle. Enter cross-compiled TDD.</p>
<span id="continue-reading"></span><h1 id="the-example-application">The Example Application</h1>
<p>We have developed the following application for our hypothetical STM1769HC12 processor which is compiled inside a proprietary IDE that we must use per our approved tool-chain.</p>
<pre style="background-color:#2b303b;">
<code class="language-c" data-lang="c"><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">bsp.h</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">frame.h</span><span style="color:#c0c5ce;">&quot;

</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">) {
  uint32_t discrete_inputs = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
  </span><span style="color:#bf616a;">frame_init</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">10</span><span style="color:#c0c5ce;">);

  </span><span style="color:#b48ead;">while </span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">) {
    discrete_inputs = </span><span style="color:#bf616a;">bsp_read_din</span><span style="color:#c0c5ce;">();
    </span><span style="color:#bf616a;">bsp_set_dout</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, discrete_inputs &amp; (</span><span style="color:#d08770;">1 </span><span style="color:#c0c5ce;">&lt;&lt; </span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">) ? </span><span style="color:#d08770;">true </span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">false</span><span style="color:#c0c5ce;">);
    </span><span style="color:#bf616a;">frame_wait_for_next</span><span style="color:#c0c5ce;">();
  }

  </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
}
</span></code></pre>
<p>There is a timing mechanism that initializes a frame length to 10 milliseconds and delays the main loop so that the application logic runs every 10 milliseconds.</p>
<p>The Board Support Package (BSP) is responsible for reading a bank of discrete input circuits, with their values packed into a 32-bit wide value, 1 bit per channel. Logic polarity is already handled for us and we can trust that a bit being set means that the input circuit is &quot;active.&quot; The value of discrete output 0 is then set based on discrete input channel 3.</p>
<p>Unfortunately, there is noise on the inputs, and the UX team doesn't like the flickering output this causes. There is now a requirement to debounce all inputs so that the state of an input must be held for 50 ms before it is considered changed.</p>
<p>You don't have access to hardware, and even if you did, verifying that you're debouncing for 50 ms and not 40 ms or 60 ms is going to require new test setups. They'll be built eventually, but for now, we want to not leave a time-bomb that is only caught during formal run-for-score.</p>
<h1 id="test-driven-development">Test Driven Development</h1>
<p>Test Driven Development simply means we write our test cases first, verify our current code fails these tests, then implement the simplest logic to make the test pass.</p>
<p>This is not to be confused with Development for Test, which I usually see used to mean developing software in such a way as to facilitate testing. This is important, too, but it misses the point of starting with the tests.</p>
<p>We're going to focus on testing a new debounce module. After talking with the developer responsible for the main loop logic, we come to an agreement on the interface.</p>
<pre style="background-color:#2b303b;">
<code class="language-c" data-lang="c"><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">bsp.h</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">frame.h</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">debouncer.h</span><span style="color:#c0c5ce;">&quot;

</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">) {
  uint32_t discrete_inputs = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
  uint32_t debounced_inputs = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
  </span><span style="color:#bf616a;">frame_init</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">10</span><span style="color:#c0c5ce;">);

  Debouncer debouncer;
  </span><span style="color:#bf616a;">debouncer_new</span><span style="color:#c0c5ce;">(&amp;debouncer, </span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">);

  </span><span style="color:#b48ead;">while </span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">) {
    discrete_inputs = </span><span style="color:#bf616a;">bsp_read_din</span><span style="color:#c0c5ce;">();
    debounced_inputs = </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, discrete_inputs);
    </span><span style="color:#bf616a;">bsp_set_dout</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">, debounced_inputs &amp; (</span><span style="color:#d08770;">1 </span><span style="color:#c0c5ce;">&lt;&lt; </span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">) ? </span><span style="color:#d08770;">true </span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">false</span><span style="color:#c0c5ce;">);
    </span><span style="color:#bf616a;">frame_wait_for_next</span><span style="color:#c0c5ce;">();
  }

  </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
}
</span></code></pre>
<p>We're pretty sure we'll need to keep track of some kind of state, since debouncing requires knowledge of past values. We'll need to check that each input has been active for 5 frames (50 ms Ã· 10 ms). Wihtout significantly affecting the flow of the main loop, we insert a <code>debouncer_update</code> function in between reading the raw discrete inputs and using that data to set outputs.</p>
<p>Before we write any code for the implementation of <code>debouncer_new</code> and <code>debouncer_update</code>, we're going to write tests.</p>
<h1 id="unity-and-cgull">Unity and CGull</h1>
<p>The <a href="https://www.throwtheswitch.org/unity">Unity Test Framework</a> is an open source library that lets you write <code>TEST_ASSERT_EQUAL_INT(5, some_variable)</code> and receive a report in a terminal if the test passes or fails. Unity is only a couple source and header files, and is as at home running directly on bare-metal embedded (with <code>putchar</code> defined) as it is on a desktop.</p>
<p>Since we don't have hardware available to test on, we are going to wrap Unity with <a href="https://github.com/superlou/cgull">CGull</a>. CGull includes the Unity libraries, and uses Python and GCC to build source files in a directory separate from the tests. It also can compile in test &quot;helpers&quot; to provide stubs to functions that would normally be included from elsewhere in the embedded project.</p>
<p>CGull compiles and runs the application source files locally, relying on the assumption that most C code that works on a desktop will behave the same on the microcontroller. This sounds like a bold assumption, but so long as the architecture has the same data widths, it's not bad. We can also segregate our modules to avoid hardware-dependent functions. Note how in this example, nothing in the debounce logic needs to understand an embedded environment: integers go in and integers come out.</p>
<h1 id="envrionment-setup">Envrionment Setup</h1>
<p>We have two folders, one for our existing embedded application, and another for our tests.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">embedded_project/
 â”œ config.proj
 â”œ bsp.c
 â”œ bsp.h
 â”œ debouncer.c
 â”œ debouncer.h
 â”œ main.c
 â”” main.h
embedded_project_cgull_tests/
 â”œ helpers/
 â”œ tests/
 â”” config.toml
</span></code></pre>
<p>In <code>embedded_project_cgull_tests/config.toml</code>, we specify where the project source code is and add whatever gcc flags we need to make the compiled code reasonably similar to the embedded processor. We also need to define a test for our debouncer module.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">target_inc = &quot;../embedded_project&quot;
target_src = &quot;../embedded_project&quot;
gcc_flags = [&quot;-m32&quot;]

[test.debouncer]
depends = [&quot;debouncer.c&quot;]
</span></code></pre>
<p>CGull will automatically look for a file named <code>test_debouncer.c</code> in the tests folder based on the section name <code>[test.debouncer]</code>. The bare minimum for this file is:</p>
<pre style="background-color:#2b303b;">
<code class="language-c" data-lang="c"><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">unity.h</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">debouncer.h</span><span style="color:#c0c5ce;">&quot;

</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
  </span><span style="color:#bf616a;">UNITY_BEGIN</span><span style="color:#c0c5ce;">();
  </span><span style="color:#bf616a;">UNITY_END</span><span style="color:#c0c5ce;">();
  </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
}
</span></code></pre>
<p>Each module we are testing will be compiled into an executable. Running <code>cgull</code> from the <code>embedded_project_cgull_tests</code> directory should result in:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">$ cgull

-----------------------
0 Tests 0 Failures 0 Ignored
OK
</span></code></pre>
<p>We haven't written any tests yet, so this isn't surprising. Lets start with a simple test that gives a single input changing over time, and expects the debounced output for all inputs to go high after the fifth occurrence.</p>
<pre style="background-color:#2b303b;">
<code class="language-c" data-lang="c"><span style="color:#65737e;">// test_debouncer.c
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">unity.h</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">debouncer.h</span><span style="color:#c0c5ce;">&quot;

</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">test_basic_debouncing</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">) {
  Debouncer debouncer;
  </span><span style="color:#bf616a;">debouncer_new</span><span style="color:#c0c5ce;">(&amp;debouncer, </span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">);

  uint32_t in = </span><span style="color:#d08770;">0xffffffff</span><span style="color:#c0c5ce;">;

  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x00000000</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x00000000</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x00000000</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x00000000</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0xffffffff</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
}

</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
  </span><span style="color:#bf616a;">UNITY_BEGIN</span><span style="color:#c0c5ce;">();
  </span><span style="color:#bf616a;">RUN_TEST</span><span style="color:#c0c5ce;">(test_basic_debouncing);
  </span><span style="color:#bf616a;">UNITY_END</span><span style="color:#c0c5ce;">();
  </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
}
</span></code></pre>
<p>Running cgull again, the output reminds us that we haven't written any implementation for our debounce module.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">$ cgull
tests/test_debouncer.c: In function â€˜test_basic_debouncingâ€™:
tests/test_debouncer.c:5:3: error: unknown type name â€˜Debouncerâ€™
    5 |   Debouncer debouncer;
      |   ^~~~~~~~~
tests/test_debouncer.c:6:3: warning: implicit declaration of function â€˜debouncer_newâ€™ [-Wimplicit-function-declaration]
    6 |   debouncer_new(&amp;debouncer, 0);
      |   ^~~~~~~~~~~~~
In file included from /home/lsimons/workspace/cgull/cgull/unity/unity.h:16,
                 from tests/test_debouncer.c:1:
tests/test_debouncer.c:12:40: warning: implicit declaration of function â€˜debouncer_updateâ€™ [-Wimplicit-function-declaration]
   12 |   TEST_ASSERT_EQUAL_UINT32(0x00000000, debouncer_update(&amp;debouncer, in));
      |                                        ^~~~~~~~~~~~~~~~
</span></code></pre>
<p>We now write code until the errors go away.</p>
<pre style="background-color:#2b303b;">
<code class="language-c" data-lang="c"><span style="color:#65737e;">// debouncer.h
</span><span style="color:#b48ead;">#ifndef</span><span style="color:#c0c5ce;"> DEBOUNCER_H_
</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">DEBOUNCER_H_

</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdint.h</span><span style="color:#c0c5ce;">&gt;

typedef </span><span style="color:#b48ead;">struct </span><span style="color:#c0c5ce;">{
} Debouncer;

</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">debouncer_new</span><span style="color:#c0c5ce;">(Debouncer *</span><span style="color:#bf616a;">debouncer</span><span style="color:#c0c5ce;">, uint8_t </span><span style="color:#bf616a;">threshold</span><span style="color:#c0c5ce;">);
uint32_t </span><span style="color:#8fa1b3;">debouncer_update</span><span style="color:#c0c5ce;">(Debouncer *</span><span style="color:#bf616a;">debouncer</span><span style="color:#c0c5ce;">, uint32_t </span><span style="color:#bf616a;">input</span><span style="color:#c0c5ce;">);

</span><span style="color:#b48ead;">#endif

</span><span style="color:#65737e;">// debouncer.c
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">debouncer.h</span><span style="color:#c0c5ce;">&quot;

</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">debouncer_new</span><span style="color:#c0c5ce;">(Debouncer *</span><span style="color:#bf616a;">debouncer</span><span style="color:#c0c5ce;">, uint8_t </span><span style="color:#bf616a;">threshold</span><span style="color:#c0c5ce;">) {

}

uint32_t </span><span style="color:#8fa1b3;">debouncer_update</span><span style="color:#c0c5ce;">(Debouncer *</span><span style="color:#bf616a;">debouncer</span><span style="color:#c0c5ce;">, uint32_t </span><span style="color:#bf616a;">input</span><span style="color:#c0c5ce;">) {

}
</span></code></pre>
<p>The cgull result is:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">$ cgull
tests/test_debouncer.c:12:test_basic_debouncing:FAIL: Expected 0 Was 1449119692

-----------------------
1 Tests 1 Failures 0 Ignored
FAIL
</span></code></pre>
<p>We can compile successfully, but we haven't implemented any debouncing logic, so the single test case fails. Our first stab will be to use a counter for each input bit and simply increment until the bit has been set the right number of times.</p>
<pre style="background-color:#2b303b;">
<code class="language-c" data-lang="c"><span style="color:#65737e;">// debouncer.h
</span><span style="color:#c0c5ce;">...
</span><span style="color:#b48ead;">typedef struct </span><span style="color:#c0c5ce;">{
  uint8_t count[</span><span style="color:#d08770;">32</span><span style="color:#c0c5ce;">];
  uint32_t threshold;
} Debouncer;
...

</span><span style="color:#65737e;">// debouncer.c
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&lt;</span><span style="color:#a3be8c;">stdbool.h</span><span style="color:#c0c5ce;">&gt;
</span><span style="color:#b48ead;">#include </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">debouncer.h</span><span style="color:#c0c5ce;">&quot;

</span><span style="color:#b48ead;">#define </span><span style="color:#c0c5ce;">NUM_DEBOUNCE_INPUTS </span><span style="color:#d08770;">32

</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">debouncer_new</span><span style="color:#c0c5ce;">(Debouncer *</span><span style="color:#bf616a;">debouncer</span><span style="color:#c0c5ce;">, uint8_t </span><span style="color:#bf616a;">threshold</span><span style="color:#c0c5ce;">) {
  uint32_t i;

  </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; NUM_DEBOUNCE_INPUTS; i++) {
    debouncer-&gt;count[i] = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
  }

  debouncer-&gt;threshold = threshold;
}

uint32_t </span><span style="color:#8fa1b3;">debouncer_update</span><span style="color:#c0c5ce;">(Debouncer *</span><span style="color:#bf616a;">debouncer</span><span style="color:#c0c5ce;">, uint32_t </span><span style="color:#bf616a;">input</span><span style="color:#c0c5ce;">) {
  uint32_t i;
  uint32_t result = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
  </span><span style="color:#b48ead;">bool</span><span style="color:#c0c5ce;"> input_is_active;

  </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; NUM_DEBOUNCE_INPUTS; i++) {
    input_is_active = (input &amp; (</span><span style="color:#d08770;">1 </span><span style="color:#c0c5ce;">&lt;&lt; i)) != </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;

    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(input_is_active) {
      debouncer-&gt;count[i]++;
    }

    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(debouncer-&gt;count[i] &gt;= debouncer-&gt;threshold) {
      result += (</span><span style="color:#d08770;">1 </span><span style="color:#c0c5ce;">&lt;&lt; i);
    }
  }

  </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> result;
}
</span></code></pre>
<p>Now, when we run cgull we get:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">$ cgull
tests/test_debouncer.c:19:test_basic_debouncing:PASS

-----------------------
1 Tests 0 Failures 0 Ignored
OK
</span></code></pre>
<p>We've done the bare minimum to pass the test. Well, it's not malicious bare minimum: we've identified that we need to treat each input separately. Lets add another test case to be sure.</p>
<pre style="background-color:#2b303b;">
<code class="language-c" data-lang="c"><span style="color:#65737e;">//test_debouncer.c
</span><span style="color:#c0c5ce;">...
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">test_debouncing_of_some_inputs</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">) {
  Debouncer debouncer;
  </span><span style="color:#bf616a;">debouncer_new</span><span style="color:#c0c5ce;">(&amp;debouncer, </span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">);

  uint32_t in = </span><span style="color:#d08770;">0xAAAA5555</span><span style="color:#c0c5ce;">;

  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x00000000</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x00000000</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x00000000</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x00000000</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0xAAAA5555</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
}

</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
  </span><span style="color:#bf616a;">UNITY_BEGIN</span><span style="color:#c0c5ce;">();
  </span><span style="color:#bf616a;">RUN_TEST</span><span style="color:#c0c5ce;">(test_basic_debouncing);
  </span><span style="color:#bf616a;">RUN_TEST</span><span style="color:#c0c5ce;">(test_debouncing_of_some_inputs);
  </span><span style="color:#bf616a;">UNITY_END</span><span style="color:#c0c5ce;">();
  </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
}
</span></code></pre><pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">lsimons@bestever:~/workspace/cgull/examples/embedded_project_cgull_tests$ cgull
tests/test_debouncer.c:32:test_basic_debouncing:PASS
tests/test_debouncer.c:33:test_basic_debouncing_of_some_inputs:PASS

-----------------------
2 Tests 0 Failures 0 Ignored
OK
</span></code></pre>
<p>We haven't checked what happens when an input is deasserted. We expect (per hypothetical requirements) that the debounce is symmetrical. 5 frames of deasserted inputs should cause the debounced value to go to 0.</p>
<pre style="background-color:#2b303b;">
<code class="language-c" data-lang="c"><span style="color:#65737e;">// test_debouncer.c
</span><span style="color:#c0c5ce;">...
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">test_debouncing_on_and_off</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">) {
  Debouncer debouncer;
  </span><span style="color:#bf616a;">debouncer_new</span><span style="color:#c0c5ce;">(&amp;debouncer, </span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">);

  uint32_t in = </span><span style="color:#d08770;">0xffffffff</span><span style="color:#c0c5ce;">;

  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x00000000</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x00000000</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x00000000</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x00000000</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0xffffffff</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0xffffffff</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0xffffffff</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0xffffffff</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0xffffffff</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x00000000</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">));
}

</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
  </span><span style="color:#bf616a;">UNITY_BEGIN</span><span style="color:#c0c5ce;">();
  </span><span style="color:#bf616a;">RUN_TEST</span><span style="color:#c0c5ce;">(test_basic_debouncing);
  </span><span style="color:#bf616a;">RUN_TEST</span><span style="color:#c0c5ce;">(test_debouncing_of_some_inputs);
  </span><span style="color:#bf616a;">RUN_TEST</span><span style="color:#c0c5ce;">(test_debouncing_on_and_off);
  </span><span style="color:#bf616a;">UNITY_END</span><span style="color:#c0c5ce;">();
  </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
}
</span></code></pre><pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">$ cgull
tests/test_debouncer.c:50:test_basic_debouncing:PASS
tests/test_debouncer.c:51:test_debouncing_of_some_inputs:PASS
tests/test_debouncer.c:45:test_debouncing_on_and_off:FAIL: Expected 0 Was 4294967295

-----------------------
3 Tests 1 Failures 0 Ignored
FAIL
</span></code></pre>
<p>And we're failing again. Since we're counting in both directions, we now need some state to keep track of which way each input was at.</p>
<pre style="background-color:#2b303b;">
<code class="language-c" data-lang="c"><span style="color:#65737e;">// debouncer.h
</span><span style="color:#c0c5ce;">...
</span><span style="color:#b48ead;">typedef struct </span><span style="color:#c0c5ce;">{
  uint8_t count[</span><span style="color:#d08770;">32</span><span style="color:#c0c5ce;">];
  uint8_t threshold;
  uint32_t state;
} Debouncer;
...

</span><span style="color:#65737e;">// debouncer.c
</span><span style="color:#c0c5ce;">...
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">debouncer_new</span><span style="color:#c0c5ce;">(Debouncer *</span><span style="color:#bf616a;">debouncer</span><span style="color:#c0c5ce;">, uint8_t </span><span style="color:#bf616a;">threshold</span><span style="color:#c0c5ce;">) {
  uint32_t i;

  </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; NUM_DEBOUNCE_INPUTS; i++) {
    debouncer-&gt;count[i] = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
  }

  debouncer-&gt;threshold = threshold;
  debouncer-&gt;state = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
}

uint32_t </span><span style="color:#8fa1b3;">debouncer_update</span><span style="color:#c0c5ce;">(Debouncer *</span><span style="color:#bf616a;">debouncer</span><span style="color:#c0c5ce;">, uint32_t </span><span style="color:#bf616a;">input</span><span style="color:#c0c5ce;">) {
  uint32_t i;
  uint32_t new_state = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
  </span><span style="color:#b48ead;">bool</span><span style="color:#c0c5ce;"> input_is_active;
  </span><span style="color:#b48ead;">bool</span><span style="color:#c0c5ce;"> debounce_was_active;

  </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; NUM_DEBOUNCE_INPUTS; i++) {
    input_is_active = (input &amp; (</span><span style="color:#d08770;">1 </span><span style="color:#c0c5ce;">&lt;&lt; i)) != </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;
    debounce_was_active = (debouncer-&gt;state &amp; (</span><span style="color:#d08770;">1 </span><span style="color:#c0c5ce;">&lt;&lt; i)) != </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">;

    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(input_is_active) {
      debouncer-&gt;count[i]++;
    } </span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
      </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(debouncer-&gt;count[i] &gt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
        debouncer-&gt;count[i]--;
      }
    }

    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(debouncer-&gt;count[i] &gt;= debouncer-&gt;threshold) {
      new_state += (</span><span style="color:#d08770;">1 </span><span style="color:#c0c5ce;">&lt;&lt; i);
    } </span><span style="color:#b48ead;">else if </span><span style="color:#c0c5ce;">(debounce_was_active &amp;&amp; (debouncer-&gt;count[i] != </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">)) {
      new_state += (</span><span style="color:#d08770;">1 </span><span style="color:#c0c5ce;">&lt;&lt; i);
    }
  }

  debouncer-&gt;state = new_state;
  </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> debouncer-&gt;state;
}
</span></code></pre><pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">$ cgull
tests/test_debouncer.c:50:test_basic_debouncing:PASS
tests/test_debouncer.c:51:test_debouncing_of_some_inputs:PASS
tests/test_debouncer.c:52:test_debouncing_on_and_off:PASS

-----------------------
3 Tests 0 Failures 0 Ignored
OK
</span></code></pre>
<p>There are also some tests that are much easier to run in this fashion than on real hardware. We know that this code is time dependent, and we are suspicious about what happens if the inputs are in the same state for many calls. This would be incredibly time prohibitive in an emulator.</p>
<pre style="background-color:#2b303b;">
<code class="language-c" data-lang="c"><span style="color:#65737e;">// test_debouncer.c
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">test_debouncing_for_a_while</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">void</span><span style="color:#c0c5ce;">) {
  Debouncer debouncer;
  </span><span style="color:#bf616a;">debouncer_new</span><span style="color:#c0c5ce;">(&amp;debouncer, </span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">);

  uint32_t in = </span><span style="color:#d08770;">0xffffffff</span><span style="color:#c0c5ce;">;

  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x00000000</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x00000000</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x00000000</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x00000000</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));

  </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(uint64_t i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; </span><span style="color:#d08770;">10000</span><span style="color:#c0c5ce;">; i++) {
    </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0xffffffff</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, in));
  }

  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0xffffffff</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0xffffffff</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0xffffffff</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">));
  </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0xffffffff</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">));

  </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(uint64_t i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; </span><span style="color:#d08770;">10000</span><span style="color:#c0c5ce;">; i++) {
    </span><span style="color:#bf616a;">TEST_ASSERT_EQUAL_UINT32</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">0x00000000</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">debouncer_update</span><span style="color:#c0c5ce;">(&amp;debouncer, </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">));
  }
}
</span></code></pre><pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">$ cgull
tests/test_debouncer.c:75:test_basic_debouncing:PASS
tests/test_debouncer.c:76:test_debouncing_of_some_inputs:PASS
tests/test_debouncer.c:77:test_debouncing_on_and_off:PASS
tests/test_debouncer.c:60:test_debouncing_for_a_while:FAIL: Expected 4294967295 Was 0

-----------------------
4 Tests 1 Failures 0 Ignored
FAIL
</span></code></pre>
<p>This test exposed an issue when counting upwards. Just like we need to not count below zero, we want to limit the counter once it hits the threshold.</p>
<pre style="background-color:#2b303b;">
<code class="language-c" data-lang="c"><span style="color:#c0c5ce;">...
</span><span style="color:#65737e;">// debouncer.c
</span><span style="color:#c0c5ce;">uint32_t </span><span style="color:#8fa1b3;">debouncer_update</span><span style="color:#c0c5ce;">(Debouncer *</span><span style="color:#bf616a;">debouncer</span><span style="color:#c0c5ce;">, uint32_t </span><span style="color:#bf616a;">input</span><span style="color:#c0c5ce;">) {
...

  </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(i = </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">; i &lt; NUM_DEBOUNCE_INPUTS; i++) {
    ...

    </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(input_is_active) {
      </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(debouncer-&gt;count[i] &lt; debouncer-&gt;threshold) {
        debouncer-&gt;count[i]++;
      }
    } </span><span style="color:#b48ead;">else </span><span style="color:#c0c5ce;">{
      </span><span style="color:#b48ead;">if </span><span style="color:#c0c5ce;">(debouncer-&gt;count[i] &gt; </span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">) {
        debouncer-&gt;count[i]--;
      }
    }

    ...
}
</span></code></pre><pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">$ cgull
tests/test_debouncer.c:75:test_basic_debouncing:PASS
tests/test_debouncer.c:76:test_debouncing_of_some_inputs:PASS
tests/test_debouncer.c:77:test_debouncing_on_and_off:PASS
tests/test_debouncer.c:78:test_debouncing_for_a_while:PASS

-----------------------
4 Tests 0 Failures 0 Ignored
OK
</span></code></pre>
<p>You can create all kinds of tests around staggering the activation of inputs and watching for unexpected effects in the outputs. This process is the basic idea of TDD. As our test definition gets better, our code gets better. If a fix breaks an existing test in your suite, you'll know immediately.</p>
<h1 id="but-you-made-fun-of-printf">But You Made Fun of <code>printf</code></h1>
<p>One cool thing with this cross-compiled approach is that if you don't have a debugger available on the desktop, you can use <code>printf</code> in the module you are developing. Since it's compiled for your desktop, it will simply print in your terminal. Just remember to remove them when done.</p>
<h1 id="do-i-really-need-cgull">Do I Really Need CGull?</h1>
<p>No. It's a half-baked Python module I threw together that composes <code>gcc</code> command-line arguments. You could use <code>make</code> or other tools. However, if you're not the only developer on a project, it's nice to use the same tool as everyone else. Agreeing on a framework like CGull makes it easier to collaborate.</p>
<h1 id="regulatory-caveat">Regulatory Caveat</h1>
<p>Sometimes regulatory standards have very strict specifications on what kind of tests can be used for credit, and how they can be developed in the software life cycle. The technique of cross-compilation used here pretty much guarantees you can't take credit for the tests executed. They don't run on the target hardware. They're not strictly traceable to formal requirements. They don't even generate the same instruction sets. So, if that's the industry you're in, think of this technique as a tool for code development and informal regression test. That said, you'll be surprised the bugs you find that the black-box verification team missed.</p>

    </div>

    
    <div class="article-info">
        
        <div class="article-date">18 July 2021</div>
        
        <div class="article-taxonomies">
            
            
                <ul class="article-tags">
                    
                    <li><a href="https://www.louissimons.com/tags/c/">#c</a></li>
                    
                    <li><a href="https://www.louissimons.com/tags/embedded/">#embedded</a></li>
                    
                </ul>
            
        </div>
    </div>

</article>


        </main>
        <footer>
            <p>
                Â© lack of focus 2021<br>
                Powered by <a target="_blank" href="https://getzola.org/">Zola</a>, Theme <a target="_blank" href="https://github.com/zbrox/anpu-zola-theme">Anpu</a>.
            </p>
            <p>
                
                
            </p>
        </footer>
    </div>
</body>
</html>
