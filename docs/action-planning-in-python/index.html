<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer-when-downgrade">

    <title>Action Planning in Python</title>
    <meta name="description" content="">

    <link rel="stylesheet" href="https://www.louissimons.com/main.css">

    

    
<link rel="stylesheet" href="https://www.louissimons.com/style.css">


</head>
<body>
    <a class="skip-main" href="#main">Skip to content</a>
    <div class="container">
        <header> 
            <h1 class="site-header">
                <a href="https:&#x2F;&#x2F;www.louissimons.com">lack of focus</a>
            </h1>
            <nav>
                


<a  href="https:&#x2F;&#x2F;www.louissimons.com&#x2F;about&#x2F;">About</a>


<a  href="https:&#x2F;&#x2F;www.louissimons.com&#x2F;fta-js">FTA</a>


<div class="search-container">
  <input id="search" type="search" placeholder="ðŸ”Ž">
  <div class="search-results" style="display: none;">
    <div class="search-results__items"></div>
  </div>
</div>

            </nav>
        </header>
        <main id="main" tabindex="-1">
            

<article class="post">
    <header>
        <h1>Action Planning in Python</h1>
    </header>
    <div class="content">
        <p>Automated planning is a field of AI techniques for determining how to transform the world from an initial state to a goal state. This guide implements a form of classical planning in which we represent the problem domain as a set of state variables that are modified by each action taken.</p>
<span id="continue-reading"></span><h1 id="how-to-boil-water">How to Boil Water</h1>
<p>We'll explore a toy problem domain: a kitchen with an empty pot sitting on the counter, a sink, and a stove. Our goal is to boil a pot of water.</p>
<p><img src="https://www.louissimons.com/action-planning-in-python/kitchen.png" alt="kitchen" /></p>
<p>The initial state, s0, and goal state can be described as:</p>
<table><thead><tr><th>Variable</th><th>s0</th><th>goal</th></tr></thead><tbody>
<tr><td>Chef position</td><td>counter</td><td></td></tr>
<tr><td>Chef holding</td><td>nothing</td><td>nothing</td></tr>
<tr><td>Pot position</td><td>counter</td><td>stove</td></tr>
<tr><td>Pot contents</td><td>empty</td><td>full</td></tr>
<tr><td>Faucet</td><td>off</td><td></td></tr>
<tr><td>Stove</td><td>off</td><td>on</td></tr>
</tbody></table>
<p>By the time the planner is done, we want a full pot on a lit stove. While the world states must be completely defined, there are some variables we don't care about to satisfy the goal. We don't care where the chef ends up or and whether the faucet is running.</p>
<p>The chef's actions can change the state of the world. If the planner tells the chef to pick up the pot, the chef's hand is now holding the pot. No other variables have changed. If the planner next tells the chef to move to the sink, both the chef's position and the pot's position change.</p>
<table><thead><tr><th>Variable</th><th>s0</th><th>pick up pot âž” s1</th><th>move to sink âž” s2</th></tr></thead><tbody>
<tr><td>Chef position</td><td>counter</td><td>counter</td><td>sink</td></tr>
<tr><td>Chef holding</td><td>empty</td><td>pot</td><td>pot</td></tr>
<tr><td>Pot position</td><td>counter</td><td>counter</td><td>sink</td></tr>
<tr><td>Pot contents</td><td>empty</td><td>empty</td><td>empty</td></tr>
<tr><td>Faucet</td><td>off</td><td>off</td><td>off</td></tr>
<tr><td>Stove</td><td>off</td><td>off</td><td>off</td></tr>
</tbody></table>
<p>However, if the chef had moved before they were holding the pot, only the chef's position would have changed.</p>
<p>Also, there are some actions that don't make any sense for a given state. From s0 or s1, the planner couldn't have the chef turn on the faucet, since they're not standing in front of the sink. There are <em>preconditions</em> that must be met for some actions to be valid at a given state. The network of all possible states connected by all valid actions creates a graph, and so the problem for the planner is to find the most efficient route through this graph from initial state to goal state.</p>
<h1 id="a-graph-traversal">A* Graph Traversal</h1>
<p><a href="https://en.wikipedia.org/wiki/Graph_traversal">Graph traversal</a> has a rich history in computer science. We will step away from our action planning problem for a few minutes and explore the A* graph traversal algorithm, though other graph traversal algorithms could work. Instead of states and actions, we'll talk nodes and edges.</p>
<p>A pseudocode implementation is <a href="https://en.wikipedia.org/wiki/A*_search_algorithm#Pseudocode">available on Wikipedia</a>, and it can be translated directly into Python (<a href="https://github.com/superlou/action_planning/blob/15175a1a9cf2a09b43827f1c6ed7b54fe884fc77/step1/a_star.py#L43">source</a>):</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">a_star</span><span>(</span><span style="color:#bf616a;">start</span><span>, </span><span style="color:#bf616a;">goal</span><span>, </span><span style="color:#bf616a;">neighbors</span><span>, </span><span style="color:#bf616a;">h</span><span>):
</span><span>    open_set = [start]
</span><span>    came_from = {}
</span><span>
</span><span>    </span><span style="color:#65737e;"># Cost of path from start node to n
</span><span>    g_score = {}
</span><span>    g_score[start] = </span><span style="color:#d08770;">0
</span><span>
</span><span>    </span><span style="color:#65737e;"># Estimated cost of path from start node through n to goal
</span><span>    </span><span style="color:#65737e;"># This is an estimate of the total path cost
</span><span>    f_score = {}
</span><span>    f_score[start] = </span><span style="color:#bf616a;">h</span><span>(start, goal)
</span><span>
</span><span>    </span><span style="color:#b48ead;">while </span><span style="color:#96b5b4;">len</span><span>(open_set) &gt; </span><span style="color:#d08770;">0</span><span>:
</span><span>        open_set.</span><span style="color:#bf616a;">sort</span><span>(</span><span style="color:#bf616a;">key</span><span>=</span><span style="color:#b48ead;">lambda </span><span style="color:#bf616a;">id</span><span>: f_score.</span><span style="color:#bf616a;">get</span><span>(</span><span style="color:#96b5b4;">id</span><span>, </span><span style="color:#bf616a;">INF</span><span>))
</span><span>        current = open_set.</span><span style="color:#bf616a;">pop</span><span>(</span><span style="color:#d08770;">0</span><span>)
</span><span>
</span><span>        </span><span style="color:#b48ead;">if </span><span>current == goal:
</span><span>            </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">reconstruct_path</span><span>(came_from, current)
</span><span>
</span><span>        </span><span style="color:#b48ead;">for </span><span>neighbor, d </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">neighbors</span><span>(current):
</span><span>            tentative_g_score = g_score.</span><span style="color:#bf616a;">get</span><span>(current, </span><span style="color:#bf616a;">INF</span><span>) + d
</span><span>            </span><span style="color:#b48ead;">if </span><span>tentative_g_score &lt; g_score.</span><span style="color:#bf616a;">get</span><span>(neighbor, </span><span style="color:#bf616a;">INF</span><span>):
</span><span>                </span><span style="color:#65737e;"># This path to neighbor is the best one seen so far
</span><span>                came_from[neighbor] = current
</span><span>                g_score[neighbor] = tentative_g_score
</span><span>                f_score[neighbor] = g_score[neighbor] + </span><span style="color:#bf616a;">h</span><span>(neighbor, goal)
</span><span>
</span><span>                </span><span style="color:#b48ead;">if </span><span>neighbor not in open_set:
</span><span>                    open_set.</span><span style="color:#bf616a;">append</span><span>(neighbor)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">reconstruct_path</span><span>(</span><span style="color:#bf616a;">came_from</span><span>, </span><span style="color:#bf616a;">current</span><span>):
</span><span>    total_path = [current]
</span><span>    </span><span style="color:#b48ead;">while </span><span>current in came_from:
</span><span>        current = came_from[current]
</span><span>        total_path.</span><span style="color:#bf616a;">insert</span><span>(</span><span style="color:#d08770;">0</span><span>, current)
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span>total_path
</span><span>
</span><span>
</span><span style="color:#bf616a;">INF </span><span>= </span><span style="color:#bf616a;">float</span><span>(&#39;</span><span style="color:#a3be8c;">inf</span><span>&#39;)
</span></code></pre>
<p>There are tons of resources on this algorithm available online that do a thorough job explaining it, but there are a few important concepts:</p>
<ul>
<li><code>g(n)</code> - Cost of the path from the start node to some node <code>n</code>. The units of cost are problem domain specific. It could be the time it takes to walk between locations, the amount of money required to perform an action, or a weighted combinations of many factors. Since the planner will be traversing forward from the start node, <code>g</code> is well-known.</li>
<li><code>h(n)</code> - A <a href="https://en.wikipedia.org/wiki/Heuristic">heuristic</a> (estimate) of the cost of the cheapest path from node <code>n</code> to the goal. This might require passing through other nodes or not, but it is simply an estimate since the planner hasn't figured out how to get from <code>n</code> to the goal yet.</li>
<li><code>f(n) = g(n) + h(n)</code> - the estimate of the cost of the total path passing through node <code>n</code>. If we are sitting at node <code>n</code> and have found new neighbor nodes, it makes sense to start looking at the neighbor with the smallest <code>f(n)</code> first if we are seeking to minimize cost.</li>
<li><code>neighbors(n)</code> - a function that returns all the nodes connected to node <code>n</code> and the cost of getting to them from <code>n</code>. The cost is <code>d</code> in the above code.</li>
<li><code>open_set</code> - the nodes that have been explored and may be &quot;expanded,&quot; i.e. their neighbors may be candidates for reaching the goal.</li>
</ul>
<p>At each iteration of the search, the search algorithm:</p>
<ol>
<li>Estimates which node in the open set is the cheapest path to the goal,</li>
<li>And if this node is the goal, returns the path it's been building,</li>
<li>Otherwise, gets the neighbors for the current node, and, if it is the cheapest path it's seen to reach this node (since there are potentially multiple paths to a node), add it to the open set so it can be investigated as a potentially cheap path to the goal.</li>
</ol>
<p>We'll test the implementation with a simple map of nodes that have positions and edges with a traversal difficulty.</p>
<p><img src="https://www.louissimons.com/action-planning-in-python/position_nodes.png" alt="Nodes" /></p>
<p>Node 1 is the start and node 6 is the goal. The nodes are physical locations on a Cartesian coordinate system, with node 1 at (0, 0) and node 6 at (6, 1). The difficulty of traveling between nodes is shown on each edge of the graph. Note that it is not necessarily the same as the distance between the nodes. The edges and positions of the nodes are described by two functions:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">neighbors</span><span>(</span><span style="color:#bf616a;">id</span><span>):
</span><span>    </span><span style="color:#65737e;"># Tuples of (destination, cost)
</span><span>    linkage_map = {
</span><span>        </span><span style="color:#d08770;">1</span><span>: [(</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">1.5</span><span>), (</span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">1.5</span><span>)],
</span><span>        </span><span style="color:#d08770;">2</span><span>: [(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">1.5</span><span>), (</span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">3.0</span><span>)],
</span><span>        </span><span style="color:#d08770;">3</span><span>: [(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">1.5</span><span>), (</span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">4.5</span><span>)],
</span><span>        </span><span style="color:#d08770;">4</span><span>: [(</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3.0</span><span>), (</span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">2.0</span><span>), (</span><span style="color:#d08770;">6</span><span>, </span><span style="color:#d08770;">2.5</span><span>)],
</span><span>        </span><span style="color:#d08770;">5</span><span>: [(</span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4.5</span><span>), (</span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">2.0</span><span>), (</span><span style="color:#d08770;">6</span><span>, </span><span style="color:#d08770;">2.5</span><span>)],
</span><span>        </span><span style="color:#d08770;">6</span><span>: [(</span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">2.5</span><span>), (</span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">2.5</span><span>)],
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span>linkage_map[</span><span style="color:#96b5b4;">id</span><span>]
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">position</span><span>(</span><span style="color:#bf616a;">id</span><span>):
</span><span>    position_map = {
</span><span>        </span><span style="color:#d08770;">1</span><span>: (</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>),
</span><span>        </span><span style="color:#d08770;">2</span><span>: (</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>),
</span><span>        </span><span style="color:#d08770;">3</span><span>: (</span><span style="color:#d08770;">2</span><span>, -</span><span style="color:#d08770;">1</span><span>),
</span><span>        </span><span style="color:#d08770;">4</span><span>: (</span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">2</span><span>),
</span><span>        </span><span style="color:#d08770;">5</span><span>: (</span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">0</span><span>),
</span><span>        </span><span style="color:#d08770;">6</span><span>: (</span><span style="color:#d08770;">6</span><span>, </span><span style="color:#d08770;">1</span><span>),
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span>position_map[</span><span style="color:#96b5b4;">id</span><span>]
</span></code></pre>
<p>Even though we know how much it costs to go between any two nodes, the cost to move from any node to the goal isn't, as we don't know what route through other nodes is necessary. However, we might expect that the distance from a node to the goal would be a decent estimate. Our implementation will use the <a href="https://en.wikipedia.org/wiki/Taxicab_geometry">Manhattan distance</a> as the heuristic.</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">heuristic</span><span>(</span><span style="color:#bf616a;">node</span><span>, </span><span style="color:#bf616a;">goal</span><span>):
</span><span>    </span><span style="color:#65737e;">&quot;&quot;&quot; Estimate of cost to reach goal from node &quot;&quot;&quot;
</span><span>    </span><span style="color:#b48ead;">return </span><span>(</span><span style="color:#96b5b4;">abs</span><span>((</span><span style="color:#bf616a;">position</span><span>(node)[</span><span style="color:#d08770;">0</span><span>] - </span><span style="color:#bf616a;">position</span><span>(goal)[</span><span style="color:#d08770;">0</span><span>]))
</span><span>            + </span><span style="color:#96b5b4;">abs</span><span>(</span><span style="color:#bf616a;">position</span><span>(node)[</span><span style="color:#d08770;">1</span><span>] - </span><span style="color:#bf616a;">position</span><span>(goal)[</span><span style="color:#d08770;">1</span><span>]))
</span></code></pre>
<p>That gives us all the pieces we need to run the path finding algorithm.</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">if </span><span>__name__ == &#39;</span><span style="color:#a3be8c;">__main__</span><span>&#39;:
</span><span>    path = </span><span style="color:#bf616a;">a_star</span><span>(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">6</span><span>, neighbors, heuristic)
</span><span>    </span><span style="color:#96b5b4;">print</span><span>(&#39;</span><span style="color:#a3be8c;">Path:</span><span>&#39;, path)
</span></code></pre>
<p>The result is:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>Path: [1, 2, 4, 6]
</span></code></pre>
<p>The full example is <a href="https://github.com/superlou/action_planning/tree/main/step2">here</a>. Play with the edge costs and see how they affect the selected path.</p>
<h1 id="introducing-the-namedtuple">Introducing the <code>namedtuple</code></h1>
<p>There's something really interesting here: the <code>a_star</code> function doesn't care what a node is. So long as a node has a unique ID and a neighbors function returns the cost of getting to new nodes with unique IDs, there's no reason this function can't operate on states and actions.</p>
<p>The A* search relies on being able to uniquely identify nodes. The dictionaries we store <code>f</code> and <code>g</code> scores in need to be able to identify if a node is new or is being revisited. When we ask for the neighbors of a node, it's very possible that we are doubling back. In the toy example earlier, we manually gave each node a unique ID.</p>
<p>Fortunately, since we're storing this information in dictionaries, and Python dictionaries can treat any hashable datatype as a key, we just need to make sure our state is hashable. To do this, we use the <code>namdetuple</code> factory function. Technically, we could use tuples, but these will make the code more readable.</p>
<p>The following captures the state of a node in the boil-water problem domain:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span>State = </span><span style="color:#bf616a;">namedtuple</span><span>(&#39;</span><span style="color:#a3be8c;">State</span><span>&#39;, (&#39;</span><span style="color:#a3be8c;">pos</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">pot_pos</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">pot_filled</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">faucet_on</span><span>&#39;,
</span><span>                             &#39;</span><span style="color:#a3be8c;">stove_on</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">holding</span><span>&#39;))
</span><span>
</span><span style="color:#65737e;"># Create an initial condition
</span><span>s0 = </span><span style="color:#bf616a;">State</span><span>(</span><span style="color:#bf616a;">pos</span><span>=&#39;</span><span style="color:#a3be8c;">counter</span><span>&#39;, </span><span style="color:#bf616a;">pot_pos</span><span>=&#39;</span><span style="color:#a3be8c;">counter</span><span>&#39;, </span><span style="color:#bf616a;">pot_filled</span><span>=</span><span style="color:#d08770;">False</span><span>,
</span><span>           </span><span style="color:#bf616a;">faucet_on</span><span>=</span><span style="color:#d08770;">False</span><span>, </span><span style="color:#bf616a;">stove_on</span><span>=</span><span style="color:#d08770;">False</span><span>, </span><span style="color:#bf616a;">holding</span><span>=</span><span style="color:#d08770;">None</span><span>)
</span></code></pre>
<p>One thing to note with tuples is that they are immutable. Their values can't be changed, but a new tuple based on another can be created.</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span>s0.pos = &#39;</span><span style="color:#a3be8c;">stove</span><span>&#39;                </span><span style="color:#65737e;"># Doesn&#39;t work
</span><span>s1 = s0.</span><span style="color:#bf616a;">_replace</span><span>(</span><span style="color:#bf616a;">pos</span><span>=&#39;</span><span style="color:#a3be8c;">stove</span><span>&#39;)   </span><span style="color:#65737e;"># Works
</span></code></pre>
<h1 id="a-new-heuristic">A New Heuristic</h1>
<p>Now that nodes don't represent physical locations, the Manhattan distance no longer works as a search heuristic. If the goal is to find a node as similar as possible to the goal, a node with fewer differing variables is likely closer to the goal. Remember, it's just an estimate to improve the search performance, not crucial to the ability of eventually finding a path.</p>
<p>We'll also recognize that not all state variables matter to our goal. In the implementation, a goal is the same type of <code>namedtuple</code> as a state, but we won't fill in all the fields and let variable that aren't important default to an Ellipsis (<code>...</code>).</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span>fields = (&#39;</span><span style="color:#a3be8c;">pos</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">pot_pos</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">pot_filled</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">faucet_on</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">stove_on</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">holding</span><span>&#39;)
</span><span>State = </span><span style="color:#bf616a;">namedtuple</span><span>(&#39;</span><span style="color:#a3be8c;">State</span><span>&#39;, fields, </span><span style="color:#bf616a;">defaults</span><span>=(</span><span style="color:#d08770;">...</span><span>,) * </span><span style="color:#96b5b4;">len</span><span>(fields))
</span><span>
</span><span>s0 = </span><span style="color:#bf616a;">State</span><span>(</span><span style="color:#bf616a;">pos</span><span>=&#39;</span><span style="color:#a3be8c;">counter</span><span>&#39;, </span><span style="color:#bf616a;">pot_pos</span><span>=&#39;</span><span style="color:#a3be8c;">counter</span><span>&#39;, </span><span style="color:#bf616a;">pot_filled</span><span>=</span><span style="color:#d08770;">False</span><span>,
</span><span>           </span><span style="color:#bf616a;">faucet_on</span><span>=</span><span style="color:#d08770;">False</span><span>, </span><span style="color:#bf616a;">stove_on</span><span>=</span><span style="color:#d08770;">False</span><span>, </span><span style="color:#bf616a;">holding</span><span>=</span><span style="color:#d08770;">None</span><span>)
</span><span>
</span><span style="color:#65737e;"># Where fields are not assigned a value, they default to Ellipsis (...)
</span><span>s_goal = </span><span style="color:#bf616a;">State</span><span>(</span><span style="color:#bf616a;">pot_pos</span><span>=&#39;</span><span style="color:#a3be8c;">stove</span><span>&#39;, </span><span style="color:#bf616a;">stove_on</span><span>=</span><span style="color:#d08770;">True</span><span>, </span><span style="color:#bf616a;">pot_filled</span><span>=</span><span style="color:#d08770;">True</span><span>, </span><span style="color:#bf616a;">holding</span><span>=</span><span style="color:#d08770;">None</span><span>)
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">heuristic</span><span>(</span><span style="color:#bf616a;">node</span><span>, </span><span style="color:#bf616a;">goal</span><span>):
</span><span>    </span><span style="color:#65737e;">&quot;&quot;&quot; Estimate of cost to reach goal from node &quot;&quot;&quot;
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">len</span><span>(</span><span style="color:#bf616a;">tuple_diff</span><span>(node, goal))
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">tuple_diff</span><span>(</span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#bf616a;">b</span><span>):
</span><span>    </span><span style="color:#65737e;">&quot;&quot;&quot;
</span><span style="color:#65737e;">    Return a list of all fields that differ between tuples a and b, ignoring
</span><span style="color:#65737e;">    fields marked Ellipsis in either field.
</span><span style="color:#65737e;">    &quot;&quot;&quot;
</span><span>    </span><span style="color:#b48ead;">return </span><span>[(field, </span><span style="color:#96b5b4;">getattr</span><span>(a, field), </span><span style="color:#96b5b4;">getattr</span><span>(b, field))
</span><span>            </span><span style="color:#b48ead;">for </span><span>field </span><span style="color:#b48ead;">in </span><span>b._fields
</span><span>            </span><span style="color:#b48ead;">if </span><span style="color:#96b5b4;">getattr</span><span>(a, field) != </span><span style="color:#96b5b4;">getattr</span><span>(b, field) and
</span><span>            </span><span style="color:#96b5b4;">getattr</span><span>(a, field) != </span><span style="color:#d08770;">... </span><span>and </span><span style="color:#96b5b4;">getattr</span><span>(b, field) != </span><span style="color:#d08770;">...</span><span>]
</span></code></pre>
<h1 id="describing-neighbors-in-the-problem-domain">Describing Neighbors in the Problem Domain</h1>
<p>The last piece missing for A* is the neighbors function. It still receives a node in the graph, now a state, but the edges between nodes, actions, are going to be more interesting. Start by adding the states that result from a &quot;move&quot; action:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">neighbors</span><span>(</span><span style="color:#bf616a;">state</span><span>):
</span><span>    </span><span style="color:#65737e;"># We still a list of connected states and the cost
</span><span>    </span><span style="color:#65737e;"># of traveling to them from the current state as tuples, but the shape
</span><span>    </span><span style="color:#65737e;"># of the function is the same as before.
</span><span>    states = [</span><span style="color:#bf616a;">move</span><span>(state, pos) </span><span style="color:#b48ead;">for </span><span>pos </span><span style="color:#b48ead;">in </span><span>[&#39;</span><span style="color:#a3be8c;">sink</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">counter</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">stove</span><span>&#39;]]
</span><span>    states = [state </span><span style="color:#b48ead;">for </span><span>state </span><span style="color:#b48ead;">in </span><span>states </span><span style="color:#b48ead;">if </span><span>state is not </span><span style="color:#d08770;">None</span><span>]
</span><span>    </span><span style="color:#b48ead;">return </span><span>states
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">move</span><span>(</span><span style="color:#bf616a;">state</span><span>, </span><span style="color:#bf616a;">to</span><span>):
</span><span>    </span><span style="color:#b48ead;">if </span><span>state.pos == to:   </span><span style="color:#65737e;"># Precondition: can&#39;t move to where you already are
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">None
</span><span>
</span><span>    state = state.</span><span style="color:#bf616a;">_replace</span><span>(</span><span style="color:#bf616a;">pos</span><span>=to)
</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>state.holding is not </span><span style="color:#d08770;">None</span><span>:
</span><span>        moving_object = {state.holding + &#39;</span><span style="color:#a3be8c;">_pos</span><span>&#39;: to}
</span><span>        state = state.</span><span style="color:#bf616a;">_replace</span><span>(**moving_object)
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span>state, </span><span style="color:#d08770;">1</span><span>, &#39;</span><span style="color:#a3be8c;">move to </span><span>&#39; + to
</span></code></pre>
<p>We start out by adding all possible move actions. The chef can move to the sink, counter, and stove at will, but it doesn't make sense to allow the chef to move to a place that he's already been. This is the <em>precondition</em>, and if the precondition isn't met, there is no new node connected. The <code>neighbors</code> function will discard it before returning the list of all neighboring state nodes. This is very similar to the approach taken by classical planners like <a href="https://en.wikipedia.org/wiki/Stanford_Research_Institute_Problem_Solver">STRIPS</a>, except it is extended to operate on procedural conditions as with <a href="https://alumni.media.mit.edu/~jorkin/goap.html">GOAP</a>.</p>
<p>All actions can be defined as functions that return a 3-value tuple with the new state, the cost of the action, and a text string describing the action. The text description isn't necessary for the A* search, but it will capture the action required to get from the start to the goal.</p>
<p>Continuing with the heavy influence from GOAP, the effects of the action are also procedural. The position of the chef is set to the passed <code>to</code> parameter, and if the chef is holding an object, the position of that object is updated as well.</p>
<p>All of the actions the chef can take are defined in the same manner: first, check if the preconditions are met, second, return a new state with the effects of the action applied. The final list of actions is:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">neighbors</span><span>(</span><span style="color:#bf616a;">state</span><span>):
</span><span>    states = []
</span><span>
</span><span>    states += [</span><span style="color:#bf616a;">move</span><span>(state, pos) </span><span style="color:#b48ead;">for </span><span>pos </span><span style="color:#b48ead;">in </span><span>[&#39;</span><span style="color:#a3be8c;">sink</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">counter</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">stove</span><span>&#39;]]
</span><span>    states += [</span><span style="color:#bf616a;">pick_up</span><span>(state, &#39;</span><span style="color:#a3be8c;">pot</span><span>&#39;), </span><span style="color:#bf616a;">put_down</span><span>(state)]
</span><span>    states += [</span><span style="color:#bf616a;">turn_on</span><span>(state, &#39;</span><span style="color:#a3be8c;">faucet</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">sink</span><span>&#39;),
</span><span>               </span><span style="color:#bf616a;">turn_off</span><span>(state, &#39;</span><span style="color:#a3be8c;">faucet</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">sink</span><span>&#39;),
</span><span>               </span><span style="color:#bf616a;">turn_on</span><span>(state, &#39;</span><span style="color:#a3be8c;">stove</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">stove</span><span>&#39;),
</span><span>               </span><span style="color:#bf616a;">turn_off</span><span>(state, &#39;</span><span style="color:#a3be8c;">stove</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">stove</span><span>&#39;)]
</span><span>    states += [</span><span style="color:#bf616a;">wait</span><span>(state)]
</span><span>
</span><span>    states = [state </span><span style="color:#b48ead;">for </span><span>state </span><span style="color:#b48ead;">in </span><span>states </span><span style="color:#b48ead;">if </span><span>state is not </span><span style="color:#d08770;">None</span><span>]
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span>states
</span></code></pre>
<p>The rest of the action functions are <a href="https://github.com/superlou/action_planning/blob/15175a1a9cf2a09b43827f1c6ed7b54fe884fc77/step4/action_planning.py#L19-L60">here</a>.</p>
<h1 id="running-the-planner">Running the Planner</h1>
<p>A tweak to the A* search algorithm is required to keep track of the action descriptions. Previously, every edge implied a &quot;move,&quot; so it wasn't needed before.</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">reconstruct_path</span><span>(</span><span style="color:#bf616a;">came_from</span><span>, </span><span style="color:#bf616a;">current</span><span>):
</span><span>    total_path = [(current, &#39;</span><span style="color:#a3be8c;">goal</span><span>&#39;)]
</span><span>
</span><span>    </span><span style="color:#b48ead;">while </span><span>current in came_from:
</span><span>        current, action = came_from[current]
</span><span>        total_path.</span><span style="color:#bf616a;">insert</span><span>(</span><span style="color:#d08770;">0</span><span>, (current, action))
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span>total_path
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">a_star</span><span>(</span><span style="color:#bf616a;">start</span><span>, </span><span style="color:#bf616a;">goal</span><span>, </span><span style="color:#bf616a;">neighbors</span><span>, </span><span style="color:#bf616a;">h</span><span>):
</span><span>  </span><span style="color:#d08770;">...
</span><span>        </span><span style="color:#b48ead;">for </span><span>neighbor, d, action </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">neighbors</span><span>(current):
</span><span>            tentative_g_score = g_score.</span><span style="color:#bf616a;">get</span><span>(current, </span><span style="color:#bf616a;">INF</span><span>) + d
</span><span>            </span><span style="color:#b48ead;">if </span><span>tentative_g_score &lt; g_score.</span><span style="color:#bf616a;">get</span><span>(neighbor, </span><span style="color:#bf616a;">INF</span><span>):
</span><span>                </span><span style="color:#65737e;"># This path to neighbor is the best one seen so far
</span><span>                came_from[neighbor] = current, action
</span><span>                g_score[neighbor] = tentative_g_score
</span><span>                f_score[neighbor] = g_score[neighbor] + </span><span style="color:#bf616a;">h</span><span>(neighbor, goal)
</span><span>
</span><span>                </span><span style="color:#b48ead;">if </span><span>neighbor not in open_set:
</span><span>                    open_set.</span><span style="color:#bf616a;">append</span><span>(neighbor)
</span><span>
</span></code></pre>
<p>With this change, the planner is run the same way as before.</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">if </span><span>__name__ == &#39;</span><span style="color:#a3be8c;">__main__</span><span>&#39;:
</span><span>    s0 = </span><span style="color:#bf616a;">State</span><span>(</span><span style="color:#bf616a;">pos</span><span>=&#39;</span><span style="color:#a3be8c;">counter</span><span>&#39;, </span><span style="color:#bf616a;">pot_pos</span><span>=&#39;</span><span style="color:#a3be8c;">counter</span><span>&#39;, </span><span style="color:#bf616a;">pot_filled</span><span>=</span><span style="color:#d08770;">False</span><span>,
</span><span>               </span><span style="color:#bf616a;">faucet_on</span><span>=</span><span style="color:#d08770;">False</span><span>, </span><span style="color:#bf616a;">stove_on</span><span>=</span><span style="color:#d08770;">False</span><span>, </span><span style="color:#bf616a;">holding</span><span>=</span><span style="color:#d08770;">None</span><span>)
</span><span>    s_goal = </span><span style="color:#bf616a;">State</span><span>(</span><span style="color:#bf616a;">pot_pos</span><span>=&#39;</span><span style="color:#a3be8c;">stove</span><span>&#39;, </span><span style="color:#bf616a;">stove_on</span><span>=</span><span style="color:#d08770;">True</span><span>, </span><span style="color:#bf616a;">pot_filled</span><span>=</span><span style="color:#d08770;">True</span><span>, </span><span style="color:#bf616a;">holding</span><span>=</span><span style="color:#d08770;">None</span><span>)
</span><span>    path = </span><span style="color:#bf616a;">a_star</span><span>(s0, s_goal, neighbors, heuristic)
</span><span>
</span><span>    </span><span style="color:#96b5b4;">print</span><span>(&#39;</span><span style="color:#a3be8c;">Path:</span><span>&#39;)
</span><span>    </span><span style="color:#b48ead;">for </span><span>step </span><span style="color:#b48ead;">in </span><span>path:
</span><span>        </span><span style="color:#96b5b4;">print</span><span>(step[</span><span style="color:#d08770;">1</span><span>])
</span></code></pre>
<p>The search result is:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>Path:
</span><span>pick up pot
</span><span>move to sink
</span><span>turn on faucet
</span><span>wait
</span><span>move to stove
</span><span>put down pot
</span><span>turn on stove
</span><span>goal
</span></code></pre>
<p>This looks pretty good, but we left the water faucet running! If we look back at <code>s_goal</code>, it's because we didn't require the faucet to be off in the goal. Making the responsible modification to the goal, the new path is:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>Path:
</span><span>pick up pot
</span><span>move to sink
</span><span>turn on faucet
</span><span>wait
</span><span>turn off faucet
</span><span>move to stove
</span><span>put down pot
</span><span>turn on stove
</span><span>goal
</span></code></pre>
<p>Much better.</p>

    </div>

    
    <div class="article-info">
        
        <div class="article-date"> 4 April 2021</div>
        
        <div class="article-taxonomies">
            
            
                <ul class="article-tags">
                    
                    <li><a href="https://www.louissimons.com/tags/ai/">#ai</a></li>
                    
                    <li><a href="https://www.louissimons.com/tags/python/">#python</a></li>
                    
                </ul>
            
        </div>
    </div>

</article>


        </main>
        <footer>
            <p>
                Â© lack of focus 2025<br>
                Powered by <a target="_blank" href="https://getzola.org/">Zola</a>, Theme <a target="_blank" href="https://github.com/zbrox/anpu-zola-theme">Anpu</a>.
            </p>
            <p>
                
                
            </p>
        </footer>
    </div>
</body>
</html>
